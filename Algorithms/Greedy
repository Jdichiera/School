A greedy algorithm is a problem-solving approach that builds a solution incrementally, making a series of choices that seem best at the moment. The key idea is to choose the option that offers the most immediate benefit or the best local optimum, with the hope that these local optimum choices will lead to a global optimum solution.

### Key Characteristics of Greedy Algorithms

1. **Local Optimal Choice**: At each step, the algorithm makes a choice that appears to be the best at that moment without considering the overall problem.

2. **Feasibility**: The chosen option must be feasible, meaning it must satisfy the problem's constraints.

3. **Irrevocability**: Once a choice is made, it cannot be undone. The algorithm does not backtrack.

4. **Optimality**: Greedy algorithms do not always guarantee an optimal solution for all problems, but they work well for certain types of problems where local optimum choices lead to a global optimum.

### Steps in a Greedy Algorithm

1. **Define the Problem**: Clearly understand the problem and its constraints.

2. **Identify the Greedy Choice Property**: Determine if making a local optimal choice at each step will lead to a global optimum.

3. **Construct the Solution**: Build the solution incrementally by making the greedy choice at each step.

4. **Verify the Solution**: Check if the constructed solution meets the problem's requirements.

### Example: Coin Change Problem

Consider the problem of making change for a certain amount of money using the fewest coins possible. Suppose you have coins of denominations 1, 5, and 10.

1. **Problem**: Make change for 28 cents.
2. **Greedy Approach**:
   - Start with the largest denomination (10 cents). You can use 2 coins of 10 cents (20 cents).
   - Next, use 1 coin of 5 cents (totaling 25 cents).
   - Finally, use 3 coins of 1 cent (totaling 28 cents).
3. **Result**: The greedy algorithm gives you 2 (10s) + 1 (5) + 3 (1s) = 6 coins in total.

### Limitations

While greedy algorithms are efficient and easy to implement, they do not guarantee an optimal solution for all problems. For example, in the coin change problem, if the denominations were 1, 3, and 4, the greedy approach might not yield the minimum number of coins.

### Common Problems Solved by Greedy Algorithms

1. **Activity Selection Problem**: Selecting the maximum number of non-overlapping activities.
2. **Huffman Coding**: A method for data compression that uses variable-length codes.
3. **Minimum Spanning Tree**: Algorithms like Prim's and Kruskal's for finding the minimum spanning tree in a graph.
4. **Dijkstra's Algorithm**: Finding the shortest path in a weighted graph.

### Conclusion

Greedy algorithms are a powerful tool for solving optimization problems, especially when the problem exhibits the properties of optimal substructure and greedy choice property. However, it's essential to analyze the specific problem to determine if a greedy approach will yield the best solution.